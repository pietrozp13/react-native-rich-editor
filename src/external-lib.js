module.exports = "(function (global) {\n  \"use strict\";\n\n  var util = newUtil();\n  var inliner = newInliner();\n  var fontFaces = newFontFaces();\n  var images = newImages();\n\n  // Default impl options\n  var defaultOptions = {\n    // Default is to fail on error, no placeholder\n    imagePlaceholder: undefined,\n    // Default cache bust is false, it will use the cache\n    cacheBust: false,\n  };\n\n  var domtoimage = {\n    toSvg: toSvg,\n    toPng: toPng,\n    toJpeg: toJpeg,\n    toBlob: toBlob,\n    toPixelData: toPixelData,\n    impl: {\n      fontFaces: fontFaces,\n      images: images,\n      util: util,\n      inliner: inliner,\n      options: {},\n    },\n  };\n\n  if (typeof module !== \"undefined\")\n    module.exports = domtoimage;\n  else global.domtoimage = domtoimage;\n\n  /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options\n     * @param {Function} options.filter - Should return true if passed node should be included in the output\n     *          (excluding node means excluding it's children as well). Not called on the root node.\n     * @param {String} options.bgcolor - color for the background, any valid CSS color value.\n     * @param {Number} options.width - width to be applied to node before rendering.\n     * @param {Number} options.height - height to be applied to node before rendering.\n     * @param {Object} options.style - an object whose properties to be copied to node's style before rendering.\n     * @param {Number} options.quality - a Number between 0 and 1 indicating image quality (applicable to JPEG only),\n                defaults to 1.0.\n     * @param {String} options.imagePlaceholder - dataURL to use as a placeholder for failed images, default behaviour is to fail fast on images we can't fetch\n     * @param {Boolean} options.cacheBust - set to true to cache bust by appending the time to the request url\n     * @return {Promise} - A promise that is fulfilled with a SVG image data URL\n     * */\n  function toSvg(node, options) {\n    options = options || {};\n    copyOptions(options);\n    return Promise.resolve(node)\n      .then(function (node) {\n        return cloneNode(\n          node,\n          options.filter,\n          true\n        );\n      })\n      .then(embedFonts)\n      .then(inlineImages)\n      .then(applyOptions)\n      .then(function (clone) {\n        return makeSvgDataUri(\n          clone,\n          options.width ||\n            util.width(node),\n          options.height ||\n            util.height(node)\n        );\n      });\n\n    function applyOptions(clone) {\n      if (options.bgcolor)\n        clone.style.backgroundColor =\n          options.bgcolor;\n\n      if (options.width)\n        clone.style.width =\n          options.width + \"px\";\n      if (options.height)\n        clone.style.height =\n          options.height + \"px\";\n\n      if (options.style)\n        Object.keys(\n          options.style\n        ).forEach(function (property) {\n          clone.style[property] =\n            options.style[property];\n        });\n\n      return clone;\n    }\n  }\n\n  /**\n   * @param {Node} node - The DOM Node object to render\n   * @param {Object} options - Rendering options, @see {@link toSvg}\n   * @return {Promise} - A promise that is fulfilled with a Uint8Array containing RGBA pixel data.\n   * */\n  function toPixelData(node, options) {\n    return draw(\n      node,\n      options || {}\n    ).then(function (canvas) {\n      return canvas\n        .getContext(\"2d\")\n        .getImageData(\n          0,\n          0,\n          util.width(node),\n          util.height(node)\n        ).data;\n    });\n  }\n\n  /**\n   * @param {Node} node - The DOM Node object to render\n   * @param {Object} options - Rendering options, @see {@link toSvg}\n   * @return {Promise} - A promise that is fulfilled with a PNG image data URL\n   * */\n  function toPng(node, options) {\n    return draw(\n      node,\n      options || {}\n    ).then(function (canvas) {\n      return canvas.toDataURL();\n    });\n  }\n\n  /**\n   * @param {Node} node - The DOM Node object to render\n   * @param {Object} options - Rendering options, @see {@link toSvg}\n   * @return {Promise} - A promise that is fulfilled with a JPEG image data URL\n   * */\n  function toJpeg(node, options) {\n    options = options || {};\n    return draw(node, options).then(\n      function (canvas) {\n        return canvas.toDataURL(\n          \"image/jpeg\",\n          options.quality || 1.0\n        );\n      }\n    );\n  }\n\n  /**\n   * @param {Node} node - The DOM Node object to render\n   * @param {Object} options - Rendering options, @see {@link toSvg}\n   * @return {Promise} - A promise that is fulfilled with a PNG image blob\n   * */\n  function toBlob(node, options) {\n    return draw(\n      node,\n      options || {}\n    ).then(util.canvasToBlob);\n  }\n\n  function copyOptions(options) {\n    // Copy options to impl options for use in impl\n    if (\n      typeof options.imagePlaceholder ===\n      \"undefined\"\n    ) {\n      domtoimage.impl.options.imagePlaceholder =\n        defaultOptions.imagePlaceholder;\n    } else {\n      domtoimage.impl.options.imagePlaceholder =\n        options.imagePlaceholder;\n    }\n\n    if (\n      typeof options.cacheBust ===\n      \"undefined\"\n    ) {\n      domtoimage.impl.options.cacheBust =\n        defaultOptions.cacheBust;\n    } else {\n      domtoimage.impl.options.cacheBust =\n        options.cacheBust;\n    }\n  }\n\n  function draw(domNode, options) {\n    return toSvg(domNode, options)\n      .then(util.makeImage)\n      .then(util.delay(100))\n      .then(function (image) {\n        var canvas = newCanvas(domNode);\n        canvas\n          .getContext(\"2d\")\n          .drawImage(image, 0, 0);\n        return canvas;\n      });\n\n    function newCanvas(domNode) {\n      var canvas = document.createElement(\n        \"canvas\"\n      );\n      canvas.width =\n        options.width ||\n        util.width(domNode);\n      canvas.height =\n        options.height ||\n        util.height(domNode);\n\n      if (options.bgcolor) {\n        var ctx = canvas.getContext(\n          \"2d\"\n        );\n        ctx.fillStyle = options.bgcolor;\n        ctx.fillRect(\n          0,\n          0,\n          canvas.width,\n          canvas.height\n        );\n      }\n\n      return canvas;\n    }\n  }\n\n  function cloneNode(\n    node,\n    filter,\n    root\n  ) {\n    if (\n      !root &&\n      filter &&\n      !filter(node)\n    )\n      return Promise.resolve();\n\n    return Promise.resolve(node)\n      .then(makeNodeCopy)\n      .then(function (clone) {\n        return cloneChildren(\n          node,\n          clone,\n          filter\n        );\n      })\n      .then(function (clone) {\n        return processClone(\n          node,\n          clone\n        );\n      });\n\n    function makeNodeCopy(node) {\n      if (\n        node instanceof\n        HTMLCanvasElement\n      ) {\n        return util.makeImage(\n          node.toDataURL()\n        );\n      }\n      return node.cloneNode(false);\n    }\n\n    function cloneChildren(\n      original,\n      clone,\n      filter\n    ) {\n      var children =\n        original.childNodes;\n      if (children.length === 0)\n        return Promise.resolve(clone);\n\n      return cloneChildrenInOrder(\n        clone,\n        util.asArray(children),\n        filter\n      ).then(function () {\n        return clone;\n      });\n\n      function cloneChildrenInOrder(\n        parent,\n        children,\n        filter\n      ) {\n        var done = Promise.resolve();\n        children.forEach(function (\n          child\n        ) {\n          done = done\n            .then(function () {\n              return cloneNode(\n                child,\n                filter\n              );\n            })\n            .then(function (\n              childClone\n            ) {\n              if (childClone)\n                parent.appendChild(\n                  childClone\n                );\n            });\n        });\n        return done;\n      }\n    }\n\n    function processClone(\n      original,\n      clone\n    ) {\n      if (!(clone instanceof Element))\n        return clone;\n\n      return Promise.resolve()\n        .then(cloneStyle)\n        .then(clonePseudoElements)\n        .then(copyUserInput)\n        .then(fixSvg)\n        .then(function () {\n          return clone;\n        });\n\n      function cloneStyle() {\n        copyStyle(\n          window.getComputedStyle(\n            original\n          ),\n          clone.style\n        );\n\n        function copyStyle(\n          source,\n          target\n        ) {\n          if (source.cssText)\n            target.cssText =\n              source.cssText;\n          else\n            copyProperties(\n              source,\n              target\n            );\n\n          function copyProperties(\n            source,\n            target\n          ) {\n            util\n              .asArray(source)\n              .forEach(function (name) {\n                target.setProperty(\n                  name,\n                  source.getPropertyValue(\n                    name\n                  ),\n                  source.getPropertyPriority(\n                    name\n                  )\n                );\n              });\n          }\n        }\n      }\n\n      function clonePseudoElements() {\n        [\":before\", \":after\"].forEach(\n          function (element) {\n            clonePseudoElement(element);\n          }\n        );\n\n        function clonePseudoElement(\n          element\n        ) {\n          var style = window.getComputedStyle(\n            original,\n            element\n          );\n          var content = style.getPropertyValue(\n            \"content\"\n          );\n\n          if (\n            content === \"\" ||\n            content === \"none\"\n          )\n            return;\n\n          var className = util.uid();\n          clone.className =\n            clone.className +\n            \" \" +\n            className;\n          var styleElement = document.createElement(\n            \"style\"\n          );\n          styleElement.appendChild(\n            formatPseudoElementStyle(\n              className,\n              element,\n              style\n            )\n          );\n          clone.appendChild(\n            styleElement\n          );\n\n          function formatPseudoElementStyle(\n            className,\n            element,\n            style\n          ) {\n            var selector =\n              \".\" +\n              className +\n              \":\" +\n              element;\n            var cssText = style.cssText\n              ? formatCssText(style)\n              : formatCssProperties(\n                  style\n                );\n            return document.createTextNode(\n              selector +\n                \"{\" +\n                cssText +\n                \"}\"\n            );\n\n            function formatCssText(\n              style\n            ) {\n              var content = style.getPropertyValue(\n                \"content\"\n              );\n              return (\n                style.cssText +\n                \" content: \" +\n                content +\n                \";\"\n              );\n            }\n\n            function formatCssProperties(\n              style\n            ) {\n              return (\n                util\n                  .asArray(style)\n                  .map(formatProperty)\n                  .join(\"; \") + \";\"\n              );\n\n              function formatProperty(\n                name\n              ) {\n                return (\n                  name +\n                  \": \" +\n                  style.getPropertyValue(\n                    name\n                  ) +\n                  (style.getPropertyPriority(\n                    name\n                  )\n                    ? \" !important\"\n                    : \"\")\n                );\n              }\n            }\n          }\n        }\n      }\n\n      function copyUserInput() {\n        if (\n          original instanceof\n          HTMLTextAreaElement\n        )\n          clone.innerHTML =\n            original.value;\n        if (\n          original instanceof\n          HTMLInputElement\n        )\n          clone.setAttribute(\n            \"value\",\n            original.value\n          );\n      }\n\n      function fixSvg() {\n        if (\n          !(clone instanceof SVGElement)\n        )\n          return;\n        clone.setAttribute(\n          \"xmlns\",\n          \"http://www.w3.org/2000/svg\"\n        );\n\n        if (\n          !(\n            clone instanceof\n            SVGRectElement\n          )\n        )\n          return;\n        [\"width\", \"height\"].forEach(\n          function (attribute) {\n            var value = clone.getAttribute(\n              attribute\n            );\n            if (!value) return;\n\n            clone.style.setProperty(\n              attribute,\n              value\n            );\n          }\n        );\n      }\n    }\n  }\n\n  function embedFonts(node) {\n    return fontFaces\n      .resolveAll()\n      .then(function (cssText) {\n        var styleNode = document.createElement(\n          \"style\"\n        );\n        node.appendChild(styleNode);\n        styleNode.appendChild(\n          document.createTextNode(\n            cssText\n          )\n        );\n        return node;\n      });\n  }\n\n  function inlineImages(node) {\n    return images\n      .inlineAll(node)\n      .then(function () {\n        return node;\n      });\n  }\n\n  function makeSvgDataUri(\n    node,\n    width,\n    height\n  ) {\n    return Promise.resolve(node)\n      .then(function (node) {\n        node.setAttribute(\n          \"xmlns\",\n          \"http://www.w3.org/1999/xhtml\"\n        );\n        return new XMLSerializer().serializeToString(\n          node\n        );\n      })\n      .then(util.escapeXhtml)\n      .then(function (xhtml) {\n        return (\n          '<foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">' +\n          xhtml +\n          \"</foreignObject>\"\n        );\n      })\n      .then(function (foreignObject) {\n        return (\n          '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' +\n          width +\n          '\" height=\"' +\n          height +\n          '\">' +\n          foreignObject +\n          \"</svg>\"\n        );\n      })\n      .then(function (svg) {\n        return (\n          \"data:image/svg+xml;charset=utf-8,\" +\n          svg\n        );\n      });\n  }\n\n  function newUtil() {\n    return {\n      escape: escape,\n      parseExtension: parseExtension,\n      mimeType: mimeType,\n      dataAsUrl: dataAsUrl,\n      isDataUrl: isDataUrl,\n      canvasToBlob: canvasToBlob,\n      resolveUrl: resolveUrl,\n      getAndEncode: getAndEncode,\n      uid: uid(),\n      delay: delay,\n      asArray: asArray,\n      escapeXhtml: escapeXhtml,\n      makeImage: makeImage,\n      width: width,\n      height: height,\n    };\n\n    function mimes() {\n      /*\n       * Only WOFF and EOT mime types for fonts are 'real'\n       * see http://www.iana.org/assignments/media-types/media-types.xhtml\n       */\n      var WOFF =\n        \"application/font-woff\";\n      var JPEG = \"image/jpeg\";\n\n      return {\n        woff: WOFF,\n        woff2: WOFF,\n        ttf:\n          \"application/font-truetype\",\n        eot:\n          \"application/vnd.ms-fontobject\",\n        png: \"image/png\",\n        jpg: JPEG,\n        jpeg: JPEG,\n        gif: \"image/gif\",\n        tiff: \"image/tiff\",\n        svg: \"image/svg+xml\",\n      };\n    }\n\n    function parseExtension(url) {\n      var match = /\\.([^\\.\\/]*?)$/g.exec(\n        url\n      );\n      if (match) return match[1];\n      else return \"\";\n    }\n\n    function mimeType(url) {\n      var extension = parseExtension(\n        url\n      ).toLowerCase();\n      return mimes()[extension] || \"\";\n    }\n\n    function isDataUrl(url) {\n      return (\n        url.search(/^(data:)/) !== -1\n      );\n    }\n\n    function toBlob(canvas) {\n      return new Promise(function (\n        resolve\n      ) {\n        var binaryString = window.atob(\n          canvas\n            .toDataURL()\n            .split(\",\")[1]\n        );\n        var length =\n          binaryString.length;\n        var binaryArray = new Uint8Array(\n          length\n        );\n\n        for (var i = 0; i < length; i++)\n          binaryArray[\n            i\n          ] = binaryString.charCodeAt(\n            i\n          );\n\n        resolve(\n          new Blob([binaryArray], {\n            type: \"image/png\",\n          })\n        );\n      });\n    }\n\n    function canvasToBlob(canvas) {\n      if (canvas.toBlob)\n        return new Promise(function (\n          resolve\n        ) {\n          canvas.toBlob(resolve);\n        });\n\n      return toBlob(canvas);\n    }\n\n    function resolveUrl(url, baseUrl) {\n      var doc = document.implementation.createHTMLDocument();\n      var base = doc.createElement(\n        \"base\"\n      );\n      doc.head.appendChild(base);\n      var a = doc.createElement(\"a\");\n      doc.body.appendChild(a);\n      base.href = baseUrl;\n      a.href = url;\n      return a.href;\n    }\n\n    function uid() {\n      var index = 0;\n\n      return function () {\n        return (\n          \"u\" +\n          fourRandomChars() +\n          index++\n        );\n\n        function fourRandomChars() {\n          /* see http://stackoverflow.com/a/6248722/2519373 */\n          return (\n            \"0000\" +\n            (\n              (Math.random() *\n                Math.pow(36, 4)) <<\n              0\n            ).toString(36)\n          ).slice(-4);\n        }\n      };\n    }\n\n    function makeImage(uri) {\n      return new Promise(function (\n        resolve,\n        reject\n      ) {\n        var image = new Image();\n        image.onload = function () {\n          resolve(image);\n        };\n        image.onerror = reject;\n        image.src = uri;\n      });\n    }\n\n    function getAndEncode(url) {\n      var TIMEOUT = 30000;\n      if (\n        domtoimage.impl.options\n          .cacheBust\n      ) {\n        // Cache bypass so we dont have CORS issues with cached images\n        // Source: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n        url +=\n          (/\\?/.test(url) ? \"&\" : \"?\") +\n          new Date().getTime();\n      }\n\n      return new Promise(function (\n        resolve\n      ) {\n        var request = new XMLHttpRequest();\n\n        request.onreadystatechange = done;\n        request.ontimeout = timeout;\n        request.responseType = \"blob\";\n        request.timeout = TIMEOUT;\n        request.open(\"GET\", url, true);\n        request.send();\n\n        var placeholder;\n        if (\n          domtoimage.impl.options\n            .imagePlaceholder\n        ) {\n          var split = domtoimage.impl.options.imagePlaceholder.split(\n            /,/\n          );\n          if (split && split[1]) {\n            placeholder = split[1];\n          }\n        }\n\n        function done() {\n          if (request.readyState !== 4)\n            return;\n\n          if (request.status !== 200) {\n            if (placeholder) {\n              resolve(placeholder);\n            } else {\n              fail(\n                \"cannot fetch resource: \" +\n                  url +\n                  \", status: \" +\n                  request.status\n              );\n            }\n\n            return;\n          }\n\n          var encoder = new FileReader();\n          encoder.onloadend = function () {\n            var content = encoder.result.split(\n              /,/\n            )[1];\n            resolve(content);\n          };\n          encoder.readAsDataURL(\n            request.response\n          );\n        }\n\n        function timeout() {\n          if (placeholder) {\n            resolve(placeholder);\n          } else {\n            fail(\n              \"timeout of \" +\n                TIMEOUT +\n                \"ms occured while fetching resource: \" +\n                url\n            );\n          }\n        }\n\n        function fail(message) {\n          console.error(message);\n          resolve(\"\");\n        }\n      });\n    }\n\n    function dataAsUrl(content, type) {\n      return (\n        \"data:\" +\n        type +\n        \";base64,\" +\n        content\n      );\n    }\n\n    function escape(string) {\n      return string.replace(\n        /([.*+?^${}()|\\[\\]\\/\\\\])/g,\n        \"\\\\$1\"\n      );\n    }\n\n    function delay(ms) {\n      return function (arg) {\n        return new Promise(function (\n          resolve\n        ) {\n          setTimeout(function () {\n            resolve(arg);\n          }, ms);\n        });\n      };\n    }\n\n    function asArray(arrayLike) {\n      var array = [];\n      var length = arrayLike.length;\n      for (var i = 0; i < length; i++)\n        array.push(arrayLike[i]);\n      return array;\n    }\n\n    function escapeXhtml(string) {\n      return string\n        .replace(/#/g, \"%23\")\n        .replace(/\\n/g, \"%0A\");\n    }\n\n    function width(node) {\n      var leftBorder = px(\n        node,\n        \"border-left-width\"\n      );\n      var rightBorder = px(\n        node,\n        \"border-right-width\"\n      );\n      return (\n        node.scrollWidth +\n        leftBorder +\n        rightBorder\n      );\n    }\n\n    function height(node) {\n      var topBorder = px(\n        node,\n        \"border-top-width\"\n      );\n      var bottomBorder = px(\n        node,\n        \"border-bottom-width\"\n      );\n      return (\n        node.scrollHeight +\n        topBorder +\n        bottomBorder\n      );\n    }\n\n    function px(node, styleProperty) {\n      var value = window\n        .getComputedStyle(node)\n        .getPropertyValue(\n          styleProperty\n        );\n      return parseFloat(\n        value.replace(\"px\", \"\")\n      );\n    }\n  }\n\n  function newInliner() {\n    var URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n\n    return {\n      inlineAll: inlineAll,\n      shouldProcess: shouldProcess,\n      impl: {\n        readUrls: readUrls,\n        inline: inline,\n      },\n    };\n\n    function shouldProcess(string) {\n      return (\n        string.search(URL_REGEX) !== -1\n      );\n    }\n\n    function readUrls(string) {\n      var result = [];\n      var match;\n      while (\n        (match = URL_REGEX.exec(\n          string\n        )) !== null\n      ) {\n        result.push(match[1]);\n      }\n      return result.filter(function (\n        url\n      ) {\n        return !util.isDataUrl(url);\n      });\n    }\n\n    function inline(\n      string,\n      url,\n      baseUrl,\n      get\n    ) {\n      return Promise.resolve(url)\n        .then(function (url) {\n          return baseUrl\n            ? util.resolveUrl(\n                url,\n                baseUrl\n              )\n            : url;\n        })\n        .then(get || util.getAndEncode)\n        .then(function (data) {\n          return util.dataAsUrl(\n            data,\n            util.mimeType(url)\n          );\n        })\n        .then(function (dataUrl) {\n          return string.replace(\n            urlAsRegex(url),\n            \"$1\" + dataUrl + \"$3\"\n          );\n        });\n\n      function urlAsRegex(url) {\n        return new RegExp(\n          \"(url\\\\(['\\\"]?)(\" +\n            util.escape(url) +\n            \")(['\\\"]?\\\\))\",\n          \"g\"\n        );\n      }\n    }\n\n    function inlineAll(\n      string,\n      baseUrl,\n      get\n    ) {\n      if (nothingToInline())\n        return Promise.resolve(string);\n\n      return Promise.resolve(string)\n        .then(readUrls)\n        .then(function (urls) {\n          var done = Promise.resolve(\n            string\n          );\n          urls.forEach(function (url) {\n            done = done.then(function (\n              string\n            ) {\n              return inline(\n                string,\n                url,\n                baseUrl,\n                get\n              );\n            });\n          });\n          return done;\n        });\n\n      function nothingToInline() {\n        return !shouldProcess(string);\n      }\n    }\n  }\n\n  function newFontFaces() {\n    return {\n      resolveAll: resolveAll,\n      impl: {\n        readAll: readAll,\n      },\n    };\n\n    function resolveAll() {\n      return readAll(document)\n        .then(function (webFonts) {\n          return Promise.all(\n            webFonts.map(function (\n              webFont\n            ) {\n              return webFont.resolve();\n            })\n          );\n        })\n        .then(function (cssStrings) {\n          return cssStrings.join(\"\\n\");\n        });\n    }\n\n    function readAll() {\n      return Promise.resolve(\n        util.asArray(\n          document.styleSheets\n        )\n      )\n        .then(getCssRules)\n        .then(selectWebFontRules)\n        .then(function (rules) {\n          return rules.map(newWebFont);\n        });\n\n      function selectWebFontRules(\n        cssRules\n      ) {\n        return cssRules\n          .filter(function (rule) {\n            return (\n              rule.type ===\n              CSSRule.FONT_FACE_RULE\n            );\n          })\n          .filter(function (rule) {\n            return inliner.shouldProcess(\n              rule.style.getPropertyValue(\n                \"src\"\n              )\n            );\n          });\n      }\n\n      function getCssRules(\n        styleSheets\n      ) {\n        var cssRules = [];\n        styleSheets.forEach(function (\n          sheet\n        ) {\n          try {\n            util\n              .asArray(\n                sheet.cssRules || []\n              )\n              .forEach(\n                cssRules.push.bind(\n                  cssRules\n                )\n              );\n          } catch (e) {\n            console.log(\n              \"Error while reading CSS rules from \" +\n                sheet.href,\n              e.toString()\n            );\n          }\n        });\n        return cssRules;\n      }\n\n      function newWebFont(webFontRule) {\n        return {\n          resolve: function resolve() {\n            var baseUrl = (\n              webFontRule.parentStyleSheet ||\n              {}\n            ).href;\n            return inliner.inlineAll(\n              webFontRule.cssText,\n              baseUrl\n            );\n          },\n          src: function () {\n            return webFontRule.style.getPropertyValue(\n              \"src\"\n            );\n          },\n        };\n      }\n    }\n  }\n\n  function newImages() {\n    return {\n      inlineAll: inlineAll,\n      impl: {\n        newImage: newImage,\n      },\n    };\n\n    function newImage(element) {\n      return {\n        inline: inline,\n      };\n\n      function inline(get) {\n        if (util.isDataUrl(element.src))\n          return Promise.resolve();\n\n        return Promise.resolve(\n          element.src\n        )\n          .then(\n            get || util.getAndEncode\n          )\n          .then(function (data) {\n            return util.dataAsUrl(\n              data,\n              util.mimeType(element.src)\n            );\n          })\n          .then(function (dataUrl) {\n            return new Promise(\n              function (\n                resolve,\n                reject\n              ) {\n                element.onload = resolve;\n                element.onerror = reject;\n                element.src = dataUrl;\n              }\n            );\n          });\n      }\n    }\n\n    function inlineAll(node) {\n      if (!(node instanceof Element))\n        return Promise.resolve(node);\n\n      return inlineBackground(\n        node\n      ).then(function () {\n        if (\n          node instanceof\n          HTMLImageElement\n        )\n          return newImage(\n            node\n          ).inline();\n        else\n          return Promise.all(\n            util\n              .asArray(node.childNodes)\n              .map(function (child) {\n                return inlineAll(child);\n              })\n          );\n      });\n\n      function inlineBackground(node) {\n        var background = node.style.getPropertyValue(\n          \"background\"\n        );\n\n        if (!background)\n          return Promise.resolve(node);\n\n        return inliner\n          .inlineAll(background)\n          .then(function (inlined) {\n            node.style.setProperty(\n              \"background\",\n              inlined,\n              node.style.getPropertyPriority(\n                \"background\"\n              )\n            );\n          })\n          .then(function () {\n            return node;\n          });\n      }\n    }\n  }\n})(this);\n";